module dffann;

import numeric;

import dffann.feedforwardnetwork;
import dffann.linearnetworks;
import dffann.multilayerperceptrons;

import std.compiler;
import std.conv;
import std.exception: enforce;
import std.file;
import std.stdio;
import std.string;
import std.range;


/*==============================================================================
*                   Compile time compatibility checks.
==============================================================================*/
/// Lowest DMD front end versions supported.
enum lowest_minor_version_dmd_supported = 71;
enum lowest_major_version_dmd_supported = 2;

pragma(msg, "Compiler is " ~ name);
pragma(msg, "Compiler id: " ~to!string(vendor));
pragma(msg, "Compiler version: " ~ to!string(version_major)~
  "."~to!string(version_minor));

enum failureString = "D language versions older than " ~ 
  to!string(lowest_major_version_dmd_supported) ~ "." ~ 
  to!string(lowest_minor_version_dmd_supported) ~ " not supported.";

// Test compiler version.
static assert(version_major >= lowest_major_version_dmd_supported &&
  version_minor >= lowest_minor_version_dmd_supported, failureMsg);

/*==============================================================================
* Utility functions that cross module boundaries more than they fit in a module
==============================================================================*/
/**
* Given a string representation of a network as generated by the stringForm
* property, parse that string, choose the right type, reconstruct the network
* and return it.
*/
FeedForwardNetwork loadFromString(const string inpt)
{
  // Break up the lines - could use split function, but that would allocate
  // a bunch of memory, all I need is first two lines. Would be nice if the
  // splitter range was sliceable.
  auto lines = lineSplitter(inpt);

  // Parse the header section
  string header0, header1;
  if(!lines.empty())
  {
    header0 = lines.front; 
    lines.popFront();
    if(!lines.empty())
      header1 = lines.front;
  }

  enforce(strip(header0) == "FeedForwardNetwork", 
    "Not a FeedForwardNetwork.");
  
  // mixin generator for making factory cases.
  string factoryCase(string name)
  {
    return "
      if(" ~ name ~ ".stringof == header1) return new " ~ name ~ "(inpt);

    ";
  }

  // Linear Networks
  mixin(factoryCase("LinRegNet"));
  mixin(factoryCase("Lin2ClsNet"));
  mixin(factoryCase("LinClsNet"));

  // Standard MLP Tanh networks
  mixin(factoryCase("MLPTanhRegNet"));
  mixin(factoryCase("MLPTanh2ClsNet"));
  mixin(factoryCase("MLPTanhClsNet"));

  // Standard MLP Sigmoid networks
  mixin(factoryCase("MLPSigRegNet"));
  mixin(factoryCase("MLPSig2ClsNet"));
  mixin(factoryCase("MLPSigClsNet"));

  // MLP atan networks
  mixin(factoryCase("MLPATanRegNet"));
  mixin(factoryCase("MLPATan2ClsNet"));
  mixin(factoryCase("MLPATanClsNet"));

  // MLP SoftPlus networks
  mixin(factoryCase("MLPSpRegNet"));
  mixin(factoryCase("MLPSp2ClsNet"));
  mixin(factoryCase("MLPSpClsNet"));

  // MLP Rectified Linear networks
  mixin(factoryCase("MLPRlRegNet"));
  mixin(factoryCase("MLPRl2ClsNet"));
  mixin(factoryCase("MLPRlClsNet"));

  throw new Exception("Invalid FeedForwardNetwork string representation.");
}

unittest
{
  mixin(announceTest("loadFromString"));

  FeedForwardNetwork[] nets = cast(FeedForwardNetwork[])[
    new LinRegNet(2,1), 
    new Lin2ClsNet(2,1), 
    new LinClsNet(12,3)];

  foreach(net; nets)
  {
    auto net2 = loadFromString(net.stringForm);
    assert(net2.stringForm == net.stringForm);
  }  
}

/**
* Save a network to a text file that can be loaded again later.
*/
void saveNetwork(FeedForwardNetwork net, in string fname)
{
  File(fname, "w").write(net.stringForm);
}

/**
 * Load a network from a text file.
 */
FeedForwardNetwork loadFromFile(in string fname)
{
  return loadFromString(readText(fname));
}
